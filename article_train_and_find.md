# Принцип работы системы классификации спама

Этот документ описывает архитектуру и логику работы системы обнаружения спама, построенной с использованием модели `all-MiniLM-L6-v2` и Redis.

## Ключевые компоненты

1.  **Модель векторизации:** `all-MiniLM-L6-v2`
2.  **База данных векторов:** Redis (с модулем RediSearch)
3.  **Источник данных для обучения:** API сайта `dev.to`
4.  **Механизм разметки:** Автоматический, на основе эвристик.

---

## Роль модели `all-MiniLM-L6-v2`

Ключевой момент: **мы не обучаем эту модель**. Мы используем её как готовый, предварительно обученный инструмент.

`all-MiniLM-L6-v2` — это компактная и быстрая модель-трансформер, которая решает одну задачу: преобразование текста (например, заголовка и описания поста) в числовой вектор (в нашем случае, массив из 384 чисел). Этот процесс называется **векторизацией** или **созданием эмбеддингов**.

Этот вектор представляет собой математическое "воплощение" смысла текста. Тексты с похожим смыслом будут иметь близкие друг к другу векторы.

Модель была выбрана за её идеальный баланс между:
*   **Качеством:** Она хорошо понимает контекст и нюансы языка.
*   **Скоростью и размером:** Она достаточно легкая для работы в реальном времени без специализированного оборудования (GPU).

---

## Процесс "Обучения" (Создание базы знаний)

Наш процесс, который мы называем "обучением", на самом деле является **созданием и наполнением базы знаний** в Redis. Вот как он устроен:

1.  **Сбор данных:** Скрипт `train_model.py` обращается к публичному API `dev.to` и скачивает сотни реальных постов.

2.  **Автоматическая разметка:** Для каждого скачанного поста запускается `SpamLabelGenerator`. Этот класс, основываясь на наборе **эвристик (правил)**, присваивает посту метку: `spam` или `not_spam`.
    *   **Примеры эвристик:** наличие спам-ключевых слов ("earn money", "buy now"), малое количество реакций, подозрительные теги, низкое число подписчиков у автора и т.д.

3.  **Векторизация:** Для каждого поста создается комбинированный вектор, который состоит из двух частей:
    *   **Текстовый вектор:** Заголовок и описание поста передаются модели `all-MiniLM-L6-v2`, которая преобразует их в числовой вектор (эмбеддинг из 384 чисел), отражающий смысл текста.
    *   **Числовые признаки:** К текстовому вектору добавляются нормализованные числовые значения: время чтения, количество подписчиков у автора и количество тегов. Это позволяет находить посты, похожие не только по смыслу, но и по структуре.

4.  **Сохранение в Redis:** В Redis для каждого поста сохраняется набор данных, включающий:
    *   Сгенерированный **вектор**.
    *   Присвоенную **метку** (`spam`/`not_spam`).
    *   **Заголовок** и **URL** поста для быстрого отображения в интерфейсе.

**Итог:** Мы не загружаем в Redis саму модель. Мы загружаем в него **результаты её работы** — векторы, которым мы сами присвоили метки.

---

## Роль Redis в классификации

Когда на проверку поступает новый, неизвестный пост, система выполняет следующие шаги:

1.  **Векторизация:** Текст нового поста так же пропускается через модель `all-MiniLM-L6-v2` для получения его вектора.

2.  **Поиск ближайших соседей (k-NN Search):** Система обращается к Redis с запросом: "Найди в базе `k` векторов, наиболее близких к вектору нового поста". (В нашей конфигурации `k=9`).

3.  **Голосование:** Система смотрит на метки (`spam`/`not_spam`), которые хранятся у найденных соседей.
    *   Если большинство соседей имеют метку `spam`, новый пост классифицируется как спам.
    *   В противном случае он считается легитимным.

Таким образом, Redis выполняет роль быстрой "картотеки", которая позволяет по "смысловому отпечатку" (вектору) нового поста мгновенно находить похожие на него посты из прошлого и делать вывод на основе их меток.