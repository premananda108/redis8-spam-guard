# Протокол Устранения Неполадок и Доработок

Этот документ описывает шаги, предпринятые для диагностики, устранения проблем и последующей доработки приложения Spam Guard.

## Часть 1: Первоначальная Настройка и Обучение (25.07.2025)

...

## Часть 2: Улучшения Веб-интерфейса и Отказоустойчивость (26.07.2025)

...

### 2.3. Реализация сбора и отображения статистики

- **Задача:** Заменить статические данные в разделе статистики на реальные, получаемые из Redis.
- **Решение:**
    1. **Сбор статистики:** Эндпоинт `/classify` был доработан для атомарного инкрементирования счетчиков `stats:total_classified` и `stats:spam_detected` в Redis после каждой классификации.
    2. **Получение статистики:** Эндпоинт `/stats` был переписан для чтения этих счетчиков из Redis. В случае недоступности Redis он возвращает нули.
    3. **Отображение точности:** В `/stats` добавлено чтение последнего показателя `accuracy` из файла `training_results.json`, чтобы в интерфейсе всегда была актуальная информация о качестве модели.
    4. **Обновление интерфейса:** Фронтенд был обновлен для корректного отображения всех новых полей статистики.

### 2.4. Исправление логики получения количества подписчиков

- **Проблема:** Несмотря на предыдущие исправления, приложение по-прежнему для всех статей показывало признак "Low follower count".
- **Расследование:**
    1. **Первоначальная гипотеза:** API `dev.to` не возвращает информацию о подписчиках в общем списке статей. Это подтвердилось.
    2. **Первая попытка исправления:** Был добавлен дополнительный запрос к API `dev.to/api/users/{user_id}` для получения полных данных о пользователе. Однако ошибка сохранилась.
    3. **Вторая попытка и обнаружение бага:** Было выявлено, что данные о подписчиках, полученные в `vectorize_post`, не передавались в `predict` для эвристического анализа, что приводило к неверной оценке.
    4. **Третья попытка и обнаружение коренной причины:** После исправления предыдущего бага ошибка все равно осталась. Финальный анализ показал, что в коде использовалось неверное имя поля для ID пользователя (`user_id` вместо `id`), из-за чего запрос к API пользователей никогда не выполнялся.
- **Решение (финальное):**
    1. В функции `create_features` исправлено имя поля на `post.user.get('id')`.
    2. В `vectorize_post` добавлена логика для корректной обработки ситуации, когда данные о подписчиках получить не удалось (используется значение `-1`).
    3. В `get_spam_indicators` добавлена проверка, чтобы причина "Low follower count" отображалась только в том случае, если данные о подписчиках были успешно загружены и их действительно мало.
    4. Логика передачи данных между `vectorize_post` и `predict` была исправлена, чтобы гарантировать консистентность данных при создании вектора и генерации текстовых причин.

## Часть 3: Отладка и улучшение процесса обучения (26.07.2025)

### 3.1. Улучшение эвристической классификации

- **Проблема:** В режиме без Redis все посты получали одинаковую, нереалистичную оценку уверенности (60% или 65%).
- **Решение:** Внедрена более гранулированная логика в `predict`:
    - 0 индикаторов: Не спам (уверенность 80%)
    - 1 индикатор: Не спам (уверенность 60%)
    - 2 индикатора: Спам (уверенность 70%)
    - 3+ индикатора: Спам (уверенность 90%)
- **Результат:** Оценка стала более динамичной и правдоподобной при работе без Redis.

### 3.2. Исправление ошибок в скрипте обучения (`train_model.py`)

- **Проблема 1:** Скрипт обучения мог запускаться без подключения к Redis, что делало его работу бессмысленной.
- **Решение 1:** В начало `train_model.py` добавлена проверка на доступность Redis. Если соединения нет, скрипт завершает работу с ошибкой.

- **Проблема 2:** Скрипт падал, так как не мог создать индекс в Redis, ожидая сообщение `Unknown Index name`, в то время как Redis возвращал `no such index`.
- **Решение 2:** В `main.py` в процедуру создания индекса добавлена проверка на оба варианта текста ошибки.

- **Проблема 3:** Модель `SentenceTransformer` загружалась в память дважды, что замедляло запуск и расходовало ресурсы.
- **Решение 3:** `train_model.py` был изменен, чтобы повторно использовать экземпляр классификатора, созданный в `main.py`, вместо создания нового.

- **Проблема 4:** Скрипт падал с ошибкой `'tuple' object has no attribute 'tobytes'`.
- **Решение 4:** В `train_model.py` исправлена логика вызова `vectorize_post`, чтобы корректно обрабатывать возвращаемый кортеж (вектор и признаки).

### 3.3. Отладка логики отображения причин классификации

- **Проблема:** После успешного обучения модель для всех постов показывала причину `Heuristic analysis based on post content`, вместо более информативной `Similar to known spam posts (via Redis)`.
- **Расследование:**
    1. **Гипотеза:** Логика в `predict` была неверной. Она показывала причину на основе Redis только в том случае, если не было найдено ни одного другого эвристического индикатора.
    2. **Попытка исправления:** Логика была изменена, чтобы причина на основе Redis всегда была основной, а остальные индикаторы добавлялись к ней.
    3. **Результат:** Проблема не решилась. Это указывает на то, что основной блок кода, использующий Redis, по какой-то причине не выполняется.
    4. **Следующий шаг:** Для дальнейшей диагностики в `predict` было добавлено логирование, чтобы отследить, сколько похожих постов возвращает Redis. Это поможет понять, почему основной блок кода игнорируется.
- **Финальное расследование и решение:**
    1. **Диагностика Redis:** Был создан и запущен диагностический скрипт (`test_redis_index.py`) для проверки состояния индекса `post_vectors` напрямую в Redis. Проверка показала, что индекс существует, содержит 962 документа и не имеет ошибок. Это подтвердило, что проблема не в данных, а в коде, который их читает.
    2. **Обнаружение коренной причины:** Анализ функции `find_similar_posts` в `main.py` выявил, что код, отвечающий за обработку ответа от Redis, был написан с ошибкой. Он неправильно разбирал структуру возвращаемых данных, из-за чего всегда возвращал пустой список, даже если похожие посты были найдены.
    3. **Решение:** Дефектный блок кода для парсинга результатов был полностью заменен на корректную реализацию, которая правильно обрабатывает сложную структуру ответа от команды `FT.SEARCH`.
- **Результат:** После исправления приложение начало корректно находить похожие посты в Redis и отображать основную причину классификации как `Similar to known spam posts (via Redis)` или `Similar to legitimate posts (via Redis)`, как и ожидалось.

## Часть 4: Добавление интерактивной проверки (26.07.2025)

### 4.1. Реализация формы для ручной проверки постов

- **Задача:** Добавить в веб-интерфейс возможность вручную вводить данные поста и получать его классификацию без необходимости искать этот пост в общей ленте.
- **Решение:**
    1.  **Модификация интерфейса:** В `main.py` была изменена HTML-структура. Страница была разделена на две колонки: основной контент слева и боковая панель (sidebar) справа.
    2.  **Добавление формы:** В боковую панель добавлена HTML-форма "Manual Post Check" с полями для всех необходимых атрибутов поста (заголовок, описание, теги, реакции, комментарии, время чтения, количество подписчиков автора).
    3.  **Реализация логики на фронтенде:**
        *   Написана новая JavaScript-функция `performManualCheck()`.
        *   Эта функция собирает данные из формы, формирует из них объект `postData`, соответствующий Pydantic-модели `DevToPost`.
        *   Для полей, которых нет в форме (ID поста, ID пользователя), генерируются случайные значения, так как они необходимы для валидации на бэкенде.
        *   Функция отправляет запрос на **существующий** эндпоинт `/classify` методом POST. Это позволило избежать написания нового кода на бэкенде.
        *   Полученный результат (диагноз поста) динамически отображается на странице прямо под формой.
- **Результат:** Приложение стало значительно более наглядным и интерактивным. Пользователь может мгновенно тестировать различные сценарии и видеть, как система реагирует на те или иные признаки спама, не сохраняя эти тестовые посты в базу данных.

## Часть 5: Оптимизация загрузки модели (27.07.2025)

### 5.1. Устранение двойной загрузки модели SentenceTransformer

- **Проблема:** При запуске приложения с помощью `python main.py` в консоли дважды появлялось сообщение `INFO:sentence_transformers.SentenceTransformer:Load pretrained SentenceTransformer: all-MiniLM-L6-v2`. Это указывало на то, что модель загружается в память дважды, что замедляло запуск и излишне расходовало ресурсы.
- **Расследование:**
    1. **Первоначальная гипотеза:** Проблема была в том, что при запуске обучения создавался новый экземпляр `RedisVectorClassifier`. Были внесены изменения для передачи существующего экземпляра в функцию обучения.
    2. **Результат:** Проблема не решилась. Это указывало на более глубокую проблему, связанную с процессом запуска.
    3. **Обнаружение коренной причины:** Было установлено, что двойная загрузка вызвана тем, как `uvicorn` обрабатывает запуск приложения. При запуске через `python main.py` скрипт выполняется один раз, а затем `uvicorn` запускает рабочий процесс, который импортирует и выполняет скрипт еще раз.
- **Решение:**
    1. **Реализация паттерна Синглтон (Singleton):** В `core.py` был создан класс `ModelSingleton`.
    2. **Ленивая загрузка:** Этот класс загружает модель `SentenceTransformer` только один раз при первом вызове метода `get_instance()`. Все последующие вызовы возвращают уже существующий в памяти экземпляр.
    3. **Интеграция:** В конструкторе `RedisVectorClassifier` прямой вызов `SentenceTransformer()` был заменен на `ModelSingleton.get_instance()`.
- **Результат:** Проблема двойной загрузки была полностью устранена. Теперь модель гарантированно загружается в память только один раз, независимо от способа запуска приложения, что повысило эффективность и скорость запуска.

## Часть 6: Улучшение отображения похожих постов (27.07.2025)

### 6.1. Добавление `title` и `url` в индекс Redis

- **Задача:** Обогатить данные, хранящиеся в Redis, добавив заголовок и URL поста. Это позволит отображать более контекстную информацию в интерфейсе.
- **Решение:**
    1.  **Обновление индекса:** В `core.py` в методе `create_index` схема индекса RediSearch была расширена полями `title` (тип `TEXT`) и `url` (тип `TAG`).
    2.  **Обновление функции сохранения:** Функция `store_training_vector` была модифицирована для приёма и сохранения `title` и `url` в хэше Redis. Добавлена проверка на `None` для совместимости с синтетическими данными.
    3.  **Обновление скрипта обучения:** В `train_model.py` вызов `store_training_vector` был изменен для передачи `post.title` и `post.url`.

### 6.2. Отображение информации о похожих постах в интерфейсе

- **Задача:** Вывести в веб-интерфейсе информацию о похожих постах, найденных в Redis.
- **Решение:**
    1.  **Бэкенд:**
        *   Функция `find_similar_posts` в `core.py` была переписана, чтобы запрашивать и возвращать `title` и `url` вместе с ID и score.
        *   Pydantic-модель `ClassificationResult` была обновлена для поддержки новой структуры данных (`similar_posts` вместо `similar_post_ids`).
        *   Эндпоинт `/classify` в `main.py` был адаптирован для формирования ответа с полной информацией о похожих постах.
    2.  **Фронтенд:**
        *   JavaScript-код в `index.html` был изменен для обработки нового формата ответа.
        *   В функциях `performManualCheck` и `loadAndClassifyPosts` добавлена логика для создания HTML-списка похожих постов с кликабельными ссылками на их `url`.
    3.  **Отладка:**
        *   Исправлена ошибка `too many values to unpack`, возникшая из-за несоответствия возвращаемых значений в `predict`.
        *   Исправлена ошибка `'str' object has no attribute 'get'`, возникшая из-за рассинхронизации данных между `predict` и `main.py`.
        *   Устранено некорректное поведение ссылок (`href=""`), когда у поста отсутствовал URL.

- **Результат:** Интерфейс стал значительно информативнее. Модератор теперь может не просто видеть, что пост похож на другие, но и сразу перейти к этим постам для анализа, что существенно ускоряет принятие решения.

## Часть 7: Реализация обратной связи от модератора (28.07.2025)

### 7.1. Добавление кнопок и логики для обратной связи

- **Задача:** Дать модераторам возможность исправлять неверные классификации модели прямо из интерфейса.
- **Решение:**
    1.  **Добавление кнопок:** В `index.html` под каждым постом был добавлен блок с кнопками "Mark as SPAM" и "Mark as LEGITIMATE".
    2.  **Реализация на фронтенде:** Написана новая JavaScript-функция `sendFeedback(postId, isSpam)`. Она собирает ID поста и вердикт модератора и отправляет их POST-запросом на эндпоинт `/feedback`.
    3.  **Подтверждение на бэкенде:** Проверено, что существующий эндпоинт `/feedback` в `main.py` корректно принимает эти данные и сохраняет их в Redis в виде ключа `feedback:<post_id>`.

### 7.2. Отображение ранее размеченных постов

- **Задача:** Сделать так, чтобы после перезагрузки страницы интерфейс "помнил", какие посты уже были размечены модератором, и отображал их статус.
- **Решение:**
    1.  **Модификация бэкенда:**
        *   В `core.py` в модель `ClassificationResult` добавлено новое необязательное поле `moderator_verdict: Optional[str]`.
        *   В `main.py` доработан эндпоинт `/classify`. Теперь перед отправкой ответа он выполняет проверку в Redis на наличие ключа `feedback:<post_id>`. Если ключ найден, вердикт модератора ("spam" или "legit") добавляется в ответ.
    2.  **Модификация фронтенда:**
        *   В `index.html` обновлена JavaScript-логика, отвечающая за отображение поста.
        *   Теперь она проверяет наличие поля `moderator_verdict` в ответе от API.
        *   Если вердикт существует, вместо кнопок обратной связи отображается статичное сообщение: **"✅ Reviewed as: SPAM"** (или LEGITIMATE).
        *   Если вердикт отсутствует, отображаются кнопки для разметки.

### 7.3. Отладка ошибок на фронтенде

- **Проблема 1:** В процессе реализации возникла ошибка `Uncaught SyntaxError: Unexpected identifier 'style'`.
- **Причина:** Некорректная попытка встроить условную логику (if/else) непосредственно в шаблонную строку JavaScript.
- **Решение:** Код был переписан. Сначала в отдельной переменной `feedbackHtml` формируется нужный HTML-код (либо кнопки, либо текст вердикта), а затем эта переменная вставляется в основной шаблон поста.

- **Проблема 2:** После первого исправления появилась ошибка `Uncaught SyntaxError: Missing catch or finally after try`.
- **Причина:** Ошибка копирования/вставки, в результате которой блок `try` остался без соответствующего блока `catch` в функции `loadAndClassifyPosts`.
- **Решение:** Вся функция `loadAndClassifyPosts` была заменена на полную, синтаксически корректную версию.

- **Результат:** Реализован полноценный цикл обратной связи. Модераторы могут исправлять ошибки модели, и эти исправления персистентны (сохраняются между сессиями), что значительно повышает удобство и эффективность работы.

## Часть 8: Улучшение интерфейса обучения модели (28.07.2025)

### 8.1. Создание "Панели управления обучением"

- **Задача:** Заменить немедленный запуск обучения на более контролируемый процесс, предоставив пользователю информацию о текущем состоянии модели перед стартом.
- **Решение:**
    1.  **Разделение интерфейса:** В `index.html` создано два основных "экрана": `moderation-view` для основной работы и `training-view` для обучения. Реализована JS-функция `switchView` для переключения между ними.
    2.  **Новый флоу:**
        *   Кнопка "Train Model" теперь не запускает обучение, а вызывает функцию `showTrainingView()`, которая переключает на экран обучения.
        *   На этом экране асинхронно запрашиваются данные с эндпоинтов `/stats` и `/redis-info`.
        *   Пользователю отображается актуальная информация: последняя известная точность модели и текущее количество обученных примеров (векторов) в Redis.
    3.  **Контролируемый запуск:** Добавлена явная кнопка "Start New Training", которая инициирует фактический процесс обучения через вызов функции `executeTraining()`.

### 8.2. Улучшение обратной связи в процессе обучения

- **Задача:** Сделать процесс наблюдения за обучением более удобным и менее навязчивым.
- **Решение:**
    1.  **Автообновление логов:** В функции `executeTraining` реализован `setInterval` для автоматического опроса эндпоинта `/get-logs` каждые 2 секунды, что обеспечивает отображение логов в реальном времени.
    2.  **Удаление `alert`:** Убрано лишнее и мешающее всплывающее окно (`alert`), которое сообщало о запуске процесса. Теперь статус обучения полностью отслеживается по логам.
    3.  **Управление состоянием кнопки:** Кнопка "Start New Training" становится неактивной на время процесса обучения, чтобы предотвратить повторные запуски.

- **Результат:** Процесс обучения стал значительно более прозрачным и управляемым. Пользователь получает всю необходимую информацию для принятия решения о запуске и может комфортно наблюдать за ходом выполнения в реальном времени.

## Часть 9: Решение проблем с зависимостями при переустановке (28.07.2025)

### 9.1. Миграция с `aioredis` на `redis.asyncio`

- **Проблема:** При попытке запуска на чистой системе возникла ошибка `TypeError: duplicate base class TimeoutError`.
- **Диагностика:** Установленная в проекте библиотека `aioredis` устарела и несовместима с современными версиями Python (3.11+).
- **Решение:** Была произведена миграция на современный асинхронный клиент, встроенный в основную библиотеку `redis`.
    1.  Из `requirements.txt` удалена зависимость `aioredis`.
    2.  В `core.py` и `main.py` импорты и код инициализации клиента были заменены на `redis.asyncio`.

### 9.2. Устранение каскадных ошибок `ModuleNotFoundError` и `pip cache`

- **Проблема 1:** После миграции появилась ошибка `ModuleNotFoundError: No module named 'redis.commands.search.indexDefinition'`.
- **Диагностика 1:** Библиотека `redis` была установлена без необходимых дополнений для векторного поиска.
- **Решение 1:** В `requirements.txt` зависимость была изменена на `redis[search]>=5.0`.

- **Проблема 2:** Несмотря на исправление, `pip` продолжал устанавливать старую (v6.2.0) и неверную библиотеку-тезку из локального кеша, что приводило к той же ошибке.
- **Диагностика 2:** Анализ вывода `pip install` показал, что используется кешированная версия пакета, который не поддерживает `[search]`.

- **Проблема 3:** При попытке принудительной переустановки возникла ошибка `OSError: [WinError 32]`, связанная с блокировкой временных файлов пакета `torch` в Windows.

- **Финальное комплексное решение:**
    1.  **Перезагрузка системы:** Пользователю было рекомендовано перезагрузить компьютер для снятия блокировки с временных файлов `torch`.
    2.  **Ручная очистка и установка:** Был предложен трехшаговый процесс для командной строки, гарантирующий установку правильной версии:
        - `pip uninstall -y redis`: Принудительное удаление некорректного пакета.
        - `pip install redis==5.0.4`: Установка конкретной последней официальной версии `redis`.
        - `pip install -r requirements.txt`: Установка всех остальных зависимостей.

- **Результат:** Комплексный подход позволил решить все проблемы с зависимостями, обеспечив чистоту и корректность окружения для запуска проекта.

## Часть 10: Финальная отладка после рефакторинга (28.07.2025)

### 10.1. Устранение ошибок, связанных с рефакторингом `core.py`

- **Проблема 1:** При запуске приложения возникала ошибка `AttributeError: 'RedisVectorClassifier' object has no attribute 'redis_client'`.
- **Диагностика:** В процессе предыдущего рефакторинга (миграции с `aioredis` на `redis.asyncio`) в файле `core.py` образовалось два конфликтующих определения класса `RedisVectorClassifier`. Кроме того, отсутствовала логика для получения URL-адреса Redis из переменных окружения.
- **Решение:**
    1.  Дублирующийся и некорректный код был полностью удален.
    2.  Все импорты были объединены и перенесены в начало файла для улучшения читаемости.
    3.  Класс `RedisVectorClassifier` был исправлен: теперь он корректно инициализируется, получая адрес Redis из переменной окружения `REDIS_URL`.

- **Проблема 2:** Сразу после первого исправления появилась ошибка `NameError: name 'getLogger' is not defined`.
- **Диагностика:** В коде была допущена опечатка: функция `getLogger` вызывалась напрямую, а не как метод модуля `logging`.
- **Решение:** Некорректный вызов `getLogger(__name__)` был заменен на правильный: `logging.getLogger(__name__)`.

- **Результат:** Последовательное устранение этих ошибок позволило успешно запустить приложение. Кодовая база `core.py` была приведена в консистентное и рабочее состояние.

### 10.2. Исправление обработки ответов от Redis

- **Проблема:** В логах появилось предупреждение `Could not parse a result from Redis search: 'str' object has no attribute 'decode'`.
- **Диагностика:** При инициализации клиента Redis был установлен флаг `decode_responses=True`, который автоматически преобразует все ответы от сервера в строки. Однако в коде остались старые вызовы `.decode('utf-8')`, которые пытались повторно декодировать уже декодированные строки.
- **Решение:** Все лишние вызовы `.decode('utf-8')` в функциях `find_similar_posts` и `predict` в файле `core.py` были удалены.
- **Результат:** Предупреждение было устранено, обработка данных от Redis стала корректной.

### 10.3. Исправление обработки данных в эндпоинте

- **Проблема:** Приложение падало с ошибкой `Classification failed: 'SimilarPostInfo' object has no attribute 'get'`.
- **Диагностика:** В эндпоинте `/classify` в файле `main.py` код ошибочно пытался обработать список Pydantic-моделей `SimilarPostInfo` так, как будто это список словарей, используя метод `.get()`.
- **Решение:** Лишнее преобразование данных было убрано. Функция `predict` теперь возвращает готовый список объектов `SimilarPostInfo`, который напрямую используется для формирования ответа.
- **Результат:** Ошибка устранена, данные между `core.py` и `main.py` передаются в консистентном формате.